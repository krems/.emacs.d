// Author: Valeriy Ovchinnikov

// FIXME: sort lexicographically, please
#include <iostream>
#include <vector>
#include <cstdlib>
#include <algorithm>
#include <limits>

/* FIXME: PRIME should be a static const field of HashCode */
// That number is prime and it's more than int range
const unsigned long long PRIME = 4294967311;

/* FIXME: SPECIAL_VALUE should be a static const field of
 * SquareMemoryHashSet */
// I believe that'll be enough big value to consider it not value
const unsigned long long SPECIAL_VALUE = 3000000000;

/* FIXME: MAX_HASH_COEFF should be a static const field of HashCode */
// max value of a_coeff in hash functions
const size_t MAX_HASH_COEFF = std::numeric_limits<int>::max();
// ratio of sum of squares of second layer tables' powers to number of numbers

/* FIXME: MEMORY_COEFF should be a static const field of FixedSet */
const size_t MEMORY_COEFF = 3;

/* FIXME: put this right after #include section */
using std::vector;
using std::cin;
using std::cout;
using std::endl;

/* FIXME: due to complexity this is a class, not struct.  Implement
 * an empty constructor and destructor
 */
// hash code functor
struct HashCode {
  void Initialize(size_t power) {
    this->power = power;
    a_coeff = 1 + rand() % (MAX_HASH_COEFF - 1);
    b_coeff = rand();
  }

  size_t operator () (int number) const {
    return ((a_coeff * number + b_coeff) % PRIME) % power;
  }
 private:
  // hash function coeffs
  unsigned long long a_coeff;
  unsigned long long b_coeff;
  // power of reflection set
  size_t power;
};
/* FIXME: delete one empty line */


class SquareMemoryHashSet {
  // hash function coeffs
  unsigned long long a_coeff;
  unsigned long long b_coeff;
  // numbers holder
  vector<unsigned long long> value_table;
  // hash function
  HashCode hash_code;

  void MakeTable(const vector<int>& numbers) {
    /* FIXME: if (value_table.empty()) ... */
    if (value_table.size() == 0) {
      return;
    }
    bool filled = false;
    while (!filled) {
      std::fill(value_table.begin(), value_table.end(), SPECIAL_VALUE);
      hash_code.Initialize(value_table.size());
      filled = true;
      for (vector<int>::const_iterator it = numbers.begin();
           it != numbers.end(); ++it) {
        size_t hash = hash_code(*it);
        if (value_table[hash] != SPECIAL_VALUE) {
          filled = false;
          break;
        } else {
          value_table[hash] = *it;
        }
      }
    }
  }

 public:
  /* FIXME: public section goes first */
  void Initialize(const vector<int>& numbers) {
    value_table.resize(numbers.size() * numbers.size(), SPECIAL_VALUE);
    MakeTable(numbers);
  }

  bool Contains(int number) const {
    /* FIXME: if (value_table.empty()) ...
    if (value_table.size() == 0) {
      return false;
    }
    size_t hash = hash_code(number);
    /* FIXME: put equality check into brackets */
    return value_table[hash] == number;
  }
};

// hash set that may contain ints and can not be changed
// build in E(t)=O(n)
// Contains in O(1)
// needs O(n) memory
class FixedSet {
  // second-layer hash tables holder
  vector<SquareMemoryHashSet> table;
  // hash function
  HashCode hash_code;

  void MakeTable(const vector<int>& numbers) {
    if (table.size() == 0) {
      return;
    }
    bool created = false;
    vector<vector<int> > cell_content(numbers.size());
    while (!created) {
      /* FIXME: delete following line. It's useless */
      std::fill(cell_content.begin(), cell_content.end(), vector<int>());
      hash_code.Initialize(table.size());
      for (vector<int>::const_iterator it = numbers.begin();
           it != numbers.end(); ++it) {
        size_t hash = hash_code(*it);
        cell_content[hash].push_back(*it);
      }
      unsigned long long second_layer_power = 0;
      /* FIXME: g++ 4.6.* supports C++11x auto keyword... */
      for (vector<vector<int> >::const_iterator it = cell_content.begin();
           it != cell_content.end(); ++it) {
        second_layer_power += ((unsigned long long)it->size() * it->size());
      }
      // we need linear memory so...
      if (second_layer_power < MEMORY_COEFF * table.size()) {
        created = true;
      }
    }
    for (vector<int>::const_iterator it = numbers.begin();
         it != numbers.end(); ++it) {
      size_t hash = hash_code(*it);
      table[hash].Initialize(cell_content[hash]);
    }
  }

 public:
  /* FIXME: public section should be first in the class declaration */
  void Initialize(const vector<int>& numbers) {
    // some kind of memset
    table.resize(numbers.size());

    MakeTable(numbers);
  }

  bool Contains(int number) const {
    if (table.size() == 0) {
      return false;
    }
    size_t hash = hash_code(number);
    return table[hash].Contains(number);
  }
};

void read_set(vector<int>& numbers) {
  size_t set_power;
  cin >> set_power;
  for (size_t i = 0; i < set_power; ++i) {
    int number;
    cin >> number;
    numbers.push_back(number);
  }
}

void read_requests(vector<int>& requests) {
  size_t requests_number;
  cin >> requests_number;
  for (size_t i = 0; i < requests_number; ++i) {
    int number;
    cin >> number;
    requests.push_back(number);
  }
}

/* FIXME: suggest to avoid returning vector and to move it to the
 * arguments list, like:
 *
 * void calculate_responses(const vector<int>& numbers,
 *                          const vector<int>& requests,
 *                          vector<bool>* answer) {
 * ...
 * }
 */
vector<bool> calculate_responses(const vector<int>& numbers,
                                 const vector<int>& requests) {
  FixedSet set;
  set.Initialize(numbers);
  /* FIXME: answer.reserve(requests.size()) */
  vector<bool> answer;
  for (vector<int>::const_iterator it = requests.begin();
       it != requests.end(); ++it) {
    answer.push_back(set.Contains(*it));
  }
  return answer;
}

void write_answer(const vector<bool>& responses) {
  for (vector<bool>::const_iterator it = responses.begin();
       it != responses.end(); ++it) {
    if (*it) {
      cout << "Yes" << endl;
    } else {
      cout << "No" << endl;
    }
  }
}

int main() {
  /* FIXME: bad idea. Use command line interger argument as a seed */
  srand(5);
  vector<int> numbers;
  read_set(numbers);
  vector<int> requests;
  read_requests(requests);
  vector<bool> responses = calculate_responses(numbers, requests);
  write_answer(responses);
  return 0;
}
