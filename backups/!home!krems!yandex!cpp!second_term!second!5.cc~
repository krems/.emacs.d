// Author: Valeriy Ovchinnikov
// Key string: kremsnx@yandex.ru - 5

#include <iostream>

template<typename ... Types> class Tuple;
template<> class Tuple<> {};
template<typename First, typename ... Rest>
class Tuple<First, Rest...>: private Tuple<Rest...> {
  First Member;
 public:
  Tuple(const First& first, const Rest& ... rest):
      Tuple<Rest...>(rest...), Member(first) {}
  
  const First& Head() const {
    return Member;
  }
  
  const Tuple<Rest...>& Tail() const {
    return *this;
  }
};

template<size_t I, class T>
struct tuple_element;

template<size_t I, class Head, class ... Rest>
struct tuple_element<I, Tuple<Head, Rest...> >:
    public tuple_element<I - 1, Tuple<Rest...> > {
  static typename tuple_element<I, Tuple<Head, Rest...> >::type
      get(const Tuple<Head, Rest...>& t) {
    return tuple_element<I - 1, Tuple<Rest...> >::get(t.Tail());
  }
};
 
template<class Head, class ... Rest>
struct tuple_element<0, Tuple<Head, Rest...> > {
  typedef Head type;
  static typename tuple_element<0, Tuple<Head, Rest...> >::type
      get(const Tuple<Head, Rest...>& t) {
    return t.Head();
  }
};

template<size_t Pos, class Head, class ... Rest>
typename tuple_element<Pos, Tuple<Head, Rest...> >::type
    Get(const Tuple<Head, Rest...>& t) {
  return tuple_element<Pos, Tuple<Head, Rest...> >::get(t);
}

int main() {
  Tuple<int, double, char> t(42, 3.14, 'a');
  std::cout << Get<0>(t) << std::endl;
  std::cout << Get<1>(t) << std::endl;
  std::cout << Get<2>(t) << std::endl;
  return 0;
}
