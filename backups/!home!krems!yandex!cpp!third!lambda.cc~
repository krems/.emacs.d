#include <algorithm>
#include <functional>
#include <iostream>
#include <iterator>

template <class E>
class Expression {
 public:
  operator E& () { return static_cast<E&>(*this); }
  operator const E& () { return static_cast<const E&>(*this); }

  int operator () (int arg) const {
    return static_cast<const E*>(this)->operator() (arg);
  }
};

class Constant : public Expression<Constant> {
 public:
  Constant(int value): value_(value) {
  }

  int operator () (int) const { return value_; }

 private:
  int value_;
};

class Identity : public Expression<Identity> {
 public:
  int operator () (int arg) const { return arg; }
};

Identity _1;

template <typename L, typename R>
class PlusExpression : public Expression<PlusExpression<L, R> > {
 public:
  PlusExpression(const L& left, const R& right)
      : left_(left), right_(right) {
  }

  int operator () (int arg) const {
    return left_(arg) + right_(arg);
  }

 private:
  L left_;
  R right_;
};

template <typename E1, typename E2>
PlusExpression<Expression<E1>, Expression<E2> > operator + (
    const Expression<E1>& lhs,
    const Expression<E2>& rhs) {
  return PlusExpression<Expression<E1>, Expression<E2> >(lhs, rhs);
}

template <typename E>
PlusExpression<Expression<E>, Constant> operator + (
    const Expression<E>& lhs,
    int rhs) {
  return PlusExpression<Expression<E>, Constant>(lhs, Constant(rhs));
}

template <typename E>
PlusExpression<Constant, Expression<E> > operator + (
    int lhs,
    const Expression<E>& rhs) {
  return PlusExpression<Constant, Expression<E> >(Constant(lhs), rhs);
}

int main() {
  int a[] = { 1, 2, 3, 4, 5 };
  std::transform(a, a + 5, std::ostream_iterator<int>(std::cout, " "), 3 + _1 + 10);
  std::cout << std::endl;
  return 0;
}
