// Author: Valeriy Ovchinnikov

#include <algorithm>
#include <cstdio>
#include <limits>
#include <vector>

typedef std::vector<std::vector<std::vector<int> > > grab_table;

const int kMaxNumCoins = 1024;
const int kInfinity = std::numeric_limits<int>::max();

enum Position {
  POSITION_LEFT  = 0,
  POSITION_RIGHT = 1,
  POSITION_COUNT
};

struct Coin {
  int coord;
  int life_time;
};

struct CompareByCoord {
  bool operator() (const Coin& lhs, const Coin& rhs) const {
    return lhs.coord < rhs.coord;
  }
};

std::vector<Coin> readCoinsData(int* num_coins) {
  scanf("%d", num_coins);
  std::vector<Coin> coins(*num_coins);  
  for (int i = 0; i < *num_coins; ++i) {
    scanf("%d%d", &coins[i].coord, &coins[i].life_time);
  }
  return coins;
}

void setInitialState(grab_table& g_table, int num_coins) {
  // for (int len = 1; len <= num_coins; ++len) {
  //   for (int left = 0; left + len <= num_coins; ++left) {
  //     g_table[len][left][POSITION_LEFT] = kInfinity;
  //     g_table[len][left][POSITION_RIGHT] = kInfinity;
  //   }
  // }

  // Ali-baba can start from any coin, so, let's initialize basic
  // states.
  for (int left = 0; left < num_coins; ++left) {
    g_table[1][left][POSITION_LEFT] = 0;
    g_table[1][left][POSITION_RIGHT] = 0;
  }
}

int findFastestWay(grab_table& g_table
                   , const std::vector<Coin>& coins
                   , int num_coins) {
  for (int len = 1; len <= num_coins; ++len) {
    for (int left = 0; left + len <= num_coins; ++left) {
      int right = left + len - 1;
      int distance = coins[right].coord - coins[left].coord;

      if (g_table[len][left][POSITION_LEFT] <
          g_table[len][left][POSITION_RIGHT]) {
        g_table[len][left][POSITION_RIGHT] =
            std::min(g_table[len][left][POSITION_RIGHT],
                     g_table[len][left][POSITION_LEFT] + distance);
      } else if (g_table[len][left][POSITION_LEFT] >
                 g_table[len][left][POSITION_RIGHT]) {
        g_table[len][left][POSITION_LEFT] =
            std::min(g_table[len][left][POSITION_LEFT],
                     g_table[len][left][POSITION_RIGHT] + distance);
      }
      if (g_table[len][left][POSITION_LEFT] != kInfinity && left > 0) {
        // We're on the left border of interval [left, right], so,
        // let's make one step to the left and grab the coin on the
        // our way.
        int cur_time = g_table[len][left][POSITION_LEFT];
        int ntime = cur_time + coins[left].coord - coins[left - 1].coord;
        if (coins[left - 1].life_time >= ntime) {
          g_table[len + 1][left - 1][POSITION_LEFT] =
              std::min(g_table[len + 1][left - 1][POSITION_LEFT], ntime);
        }
      }
      if (g_table[len][left][POSITION_RIGHT] !=kInfinity &&
          right + 1 < num_coins) {
        // We're on the right border of interval [left, right], so,
        // let's make one step to the right and grab the coins on the
        // our way.
        int cur_time = g_table[len][left][POSITION_RIGHT];
        int ntime = cur_time + coins[right + 1].coord - coins[right].coord;
        if (coins[right + 1].life_time >= ntime) {
          g_table[len + 1][left][POSITION_RIGHT] =
              std::min(g_table[len + 1][left][POSITION_RIGHT], ntime);
        }
      }
    }
  }

  // We can finish on the left or on the right border.
  return std::min(g_table[num_coins][0][POSITION_LEFT],
                  g_table[num_coins][0][POSITION_RIGHT]);
}

void writeAnswer(int best) {
  if (best != kInfinity) {
    printf("%d\n", best);
  } else {
    printf("No solution\n");
  }
}

int main() {
  // g_table[len][left][position] is the minimum time needed to grab all
  // coins with indices i such that left <= i < left + len and to be on
  // the left (if position == POSITION_LEFT) or on the right (if
  // position == POSITION_RIGHT) border of this interval.
  grab_table g_table(kMaxNumCoins + 1, std::vector<std::vector<int> >
                    (kMaxNumCoins, std::vector<int>(POSITION_COUNT, kInfinity)));
  int num_coins;
  std::vector<Coin> coins(readCoinsData(&num_coins));
  std::sort(coins.begin(), coins.end(), CompareByCoord());
  setInitialState(g_table, num_coins);
  int best = findFastestWay(g_table, coins, num_coins);
  writeAnswer(best);
  return 0;
}
