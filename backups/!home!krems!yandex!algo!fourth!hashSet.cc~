// Author: Valeriy Ovchinnikov

#include <iostream>
#include <vector>
#include <cstdlib>

using std::vector;
using std::cin;
using std::cout;
using std::endl;

// sl - second layer
// fl - first layer

// hash set that may contain ints and can not be changed
// build in E(t)=O(n)
// Contains in O(1)
// needs O(n) memory
class FixedSet {
  // That number is prime and it's more than int range
  const static unsigned long long PRIME = 4294967311;
  // I believe that'll be enough big value to consider 
  // it's infinity
  const static unsigned long long INFINITY = 3000000000;
  
  // this one'll be hashtable with all input data
  vector<vector<unsigned long long> > table;

  // a_first, b_first - coeffs of first-layer hash function
  // set_power is the power of first layer set wich is equal 
  // to number of numbers in hash table
  unsigned long long a_first, b_first;
  size_t set_power;
  // a_coeffs, b_coeffs - coeffs of second-layer hash functions
  vector<unsigned long long> a_coeffs;
  vector<unsigned long long> b_coeffs;
  // sl_sets_powers consists of powers of every second-layer set
  vector<size_t> sl_sets_powers;
  // fl_content carring info about what numbers are in each cell 
  // of first-layer set so it indicates first-layer  collisions
  vector<vector<int> > fl_content;
  // hash_calculated indicates if appropriate cell had been filled
  vector<bool> hash_calculated;

  void Set_coeffs(unsigned long long* lhs, 
                  unsigned long long* rhs) {
    *lhs = rand();
    *rhs = rand();
  }
  
  size_t First_layer_hash(int number) const {
    size_t hash_code = ((a_first * number + b_first) % PRIME) 
      % set_power;
    return hash_code;
  }

  size_t Second_layer_hash(int number,
                           size_t table_number) const {
    size_t hash_code = ((a_coeffs.at(table_number) * number
                         + b_coeffs.at(table_number)) % PRIME)
      % sl_sets_powers.at(table_number);
    return hash_code;
  }

  void Calculate_hashcodes_powers(const vector<size_t>&
                                  distribution) {
    size_t cell_number = 0;
    for (vector<size_t>::const_iterator it = distribution.begin();
         it != distribution.end(); ++it) {
      sl_sets_powers[cell_number] = (*it) * (*it);
      // to avoid division by zero
      if (*it == 0) {
        sl_sets_powers[cell_number] = 1;
      }
      ++cell_number;
    }
  }
  
  void Make_first_layer(const vector<int>& numbers) {
    // distribution calculates how many collisions are in 
    // every cell
    vector<size_t> distribution(numbers.size(), 0);
    Set_coeffs(&a_first, &b_first);
    for (vector<int>::const_iterator it = numbers.begin();
         it != numbers.end(); ++it) {
      size_t hash = First_layer_hash(*it);
      fl_content[hash].push_back(*it);
      ++distribution[hash];
    }
    size_t second_layer_length = 0;
    for (vector<size_t>::const_iterator it = distribution.begin();
         it != distribution.end(); ++it) {
      second_layer_length += ((*it) * (*it));
    }
    // we need linear memory so...
    if (second_layer_length > 3 * set_power) {
      for (size_t i = 0; i < fl_content.size(); ++i) {
        fl_content[i].clear();
      }
      Make_first_layer(numbers);
      return;
    }
    Calculate_hashcodes_powers(distribution);
  }

  void Make_sl_hash_function(size_t index) {
    Set_coeffs(&a_coeffs[index], &b_coeffs[index]);
    vector<bool> sl_table(sl_sets_powers[index], false);
    for (vector<int>::const_iterator it = 
             fl_content[index].begin();
         it != fl_content[index].end(); ++it) {
      size_t sl_hash = Second_layer_hash(*it, index);
      if (sl_table[sl_hash]) {
        Make_sl_hash_function(index);
        return;
      } else {
        sl_table[sl_hash] = true;
      }
    }
  }

  void Make_second_layers(const vector<int>& numbers) {
    for (vector<int>::const_iterator it = numbers.begin();
         it != numbers.end(); ++it) {
      size_t fl_hash = First_layer_hash(*it);
      // if we've already made hash_function for the cell
      if (hash_calculated[fl_hash]) {
        size_t sl_hash = Second_layer_hash(*it, fl_hash);
        table[fl_hash][sl_hash] = *it;
        continue;
      }
      Make_sl_hash_function(fl_hash);
      size_t sl_hash = Second_layer_hash(*it, fl_hash);
      table[fl_hash][sl_hash] = *it;
      hash_calculated[fl_hash] = true;
    }
  }
  
  // let's fill empty first-layer cells to avoid segfaults
  void Fill_left_cells() {
    for (size_t i = 0; i < table.size(); ++i) {
      if (hash_calculated[i]) {
        continue;
      }
      a_coeffs[i] = 0;
      b_coeffs[i] = 0;
      table[i].resize(1, INFINITY);
    }
  }

  // now we know powers of second-layer sets, so we prepare 
  // space in table
  void Prepare_memory() {
    size_t index = 0;
    for (vector<size_t>::iterator it = sl_sets_powers.begin();
         it != sl_sets_powers.end(); ++it) {
      table[index].resize(*it, INFINITY);
      ++index;
    }
  }

 public:

  // I like 5
  FixedSet() {
    srand(5);
  }
  
  void Initialize(const vector<int>& numbers) {
    // some kind of memset
    set_power = numbers.size();
    table.resize(numbers.size());
    a_coeffs.resize(numbers.size());
    b_coeffs.resize(numbers.size());
    fl_content.resize(numbers.size());
    sl_sets_powers.resize(numbers.size());
    hash_calculated.resize(numbers.size(), false);

    Make_first_layer(numbers);
    Prepare_memory();
    Make_second_layers(numbers);
    Fill_left_cells();
  }
  
  bool Contains(int number) const {
    size_t first = First_layer_hash(number);
    size_t second = Second_layer_hash(number, first);
    if (table[first][second] == number) {
      return true;
    }
    return false;
  }
};


void read_set(vector<int>& numbers) {
  size_t set_power;
  cin >> set_power;
  for (size_t i = 0; i < set_power; ++i) {
    int number;
    cin >> number;
    numbers.push_back(number);
  }
}

void read_request(vector<int>& requests) {
  size_t requests_number;
  cin >> requests_number;
  for (size_t i = 0; i < requests_number; ++i) {
    int number;
    cin >> number;
    requests.push_back(number);
  }
}

void write_answer(const FixedSet& set, const vector<int>& requests) {
  for (size_t i = 0; i < requests.size(); ++i) {
    if (set.Contains(requests.at(i))) {
      cout << "Yes" << endl;
    } else {
      cout << "No" << endl;
    }
  }
}

int main() {
  FixedSet set;
  vector<int> numbers;
  read_set(numbers);
  set.Initialize(numbers);
  vector<int> requests;
  read_request(requests);
  write_answer(set, requests);
  return 0;
}
