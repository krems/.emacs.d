#include <algorithm>
#include <iostream>
#include <iterator>

template <typename E, typename A1, typename A2>
struct ExpressionTraits;

template <typename L, typename R>
class PlusExpression;

template <typename L, typename R>
class MinusExpression;

template <typename L, typename R>
class LessExpression;

template <typename L, typename R>
class GreaterExpression;

template <typename L, typename R>
class OutputExpression;

class Placeholder1;
class Placeholder2;

template <typename T>
class Constant;

template <typename T>
class Reference;

template<typename L, typename R, typename A1, typename A2>
struct ExpressionTraits<PlusExpression<L, R>, A1, A2> {
  typedef A1 ResultType;
};

template<typename L, typename R, typename A1, typename A2>
struct ExpressionTraits<MinusExpression<L, R>, A1, A2> {
  typedef A1 ResultType;
};

template<typename L, typename R, typename A1, typename A2>
struct ExpressionTraits<LessExpression<L, R>, A1, A2> {
  typedef bool ResultType;
};

template<typename L, typename R, typename A1, typename A2>
struct ExpressionTraits<GreaterExpression<L, R>, A1, A2> {
  typedef bool ResultType;
};

template<typename L, typename R, typename A1, typename A2>
struct ExpressionTraits<OutputExpression<L, R>, A1, A2> {
  typedef std::ostream& ResultType;
};

template <typename A1, typename A2>
struct ExpressionTraits<Placeholder1, A1, A2> {
  typedef A1 ResultType;
};

template <typename A1, typename A2>
struct ExpressionTraits<Placeholder2, A1, A2> {
  typedef A2 ResultType;
};

template <typename T, typename A1, typename A2>
struct ExpressionTraits<Constant<T>, A1, A2> {
  typedef T ResultType;
};

template <typename T, typename A1, typename A2>
struct ExpressionTraits<Reference<T>, A1, A2> {
  typedef T& ResultType;
};

template <class E>
class Expression {
 public:
  operator E& () { return static_cast<E&>(*this); }
  operator const E& () const { return static_cast<const E&>(*this); }

  template <typename A1>
  typename ExpressionTraits<E, A1, void>::ResultType
  operator () (const A1& a1) const {
    return static_cast<const E*>(this)->operator ()<A1>(a1);
  }

  template <typename A1, typename A2>
  typename ExpressionTraits<E, A1, A2>::ResultType
  operator () (const A1& a1, const A2& a2) const {
    return static_cast<const E*>(this)->operator ()<A1, A2>(a1, a2);
  }
};

template <typename L, typename R>
class PlusExpression : public Expression<PlusExpression<L, R> > {
 public:
  PlusExpression(const L& lhs, const R& rhs): lhs_(lhs), rhs_(rhs) {
  }

  template <typename A1>
  A1 operator () (const A1& a1) const {
    return lhs_(a1) + rhs_(a1);
  }

  template <typename A1, typename A2>
  A1 operator () (const A1& a1, const A2& a2) const {
    return lhs_(a1, a2) + rhs_(a1, a2);
  }

 private:
  L lhs_;
  R rhs_;
};

template <typename L, typename R>
class MinusExpression : public Expression<MinusExpression<L, R> > {
 public:
  MinusExpression(const L& lhs, const R& rhs): lhs_(lhs), rhs_(rhs) {
  }

  template <typename A1>
  A1 operator () (const A1& a1) const {
    return lhs_(a1) + rhs_(a1);
  }

  template <typename A1, typename A2>
  A1 operator () (const A1& a1, const A2& a2) const {
    return lhs_(a1, a2) + rhs_(a1, a2);
  }

 private:
  L lhs_;
  R rhs_;
};

template <typename L, typename R>
class LessExpression : public Expression<LessExpression<L, R> > {
 public:
  LessExpression(const L& lhs, const R& rhs): lhs_(lhs), rhs_(rhs) {
  }

  template <typename A1>
  bool operator () (const A1& a1) const {
    return lhs_(a1) < rhs_(a1);
  }

  template <typename A1, typename A2>
  bool operator () (const A1& a1, const A2& a2) const {
    return lhs_(a1, a2) < rhs_(a1, a2);
  }

 private:
  L lhs_;
  R rhs_;
};

template <typename L, typename R>
class GreaterExpression : public Expression<GreaterExpression<L, R> > {
 public:
  GreaterExpression(const L& lhs, const R& rhs): lhs_(lhs), rhs_(rhs) {
  }

  template <typename A1>
  bool operator () (const A1& a1) const {
    return lhs_(a1) > rhs_(a1);
  }

  template <typename A1, typename A2>
  bool operator () (const A1& a1, const A2& a2) const {
    return lhs_(a1, a2) > rhs_(a1, a2);
  }

 private:
  L lhs_;
  R rhs_;
};

template <typename L, typename R>
class OutputExpression : public Expression<OutputExpression<L, R> > {
 public:
  OutputExpression(const L& lhs, const R& rhs)
  : lhs_(lhs), rhs_(rhs) {
  }

  template <typename A1>
  std::ostream& operator () (const A1& a1) const {
    return lhs_(a1) << rhs_(a1);
  }

  template <typename A1, typename A2>
  std::ostream& operator () (const A1& a1, const A2& a2) const {
    return lhs_(a1, a2) << rhs_(a1, a2);
  }

 private:
  const L& lhs_;
  const R& rhs_;
};

class Placeholder1 : public Expression<Placeholder1> {
 public:
  template <typename A1>
  A1 operator () (const A1& a1) const {
    return a1;
  }

  template <typename A1, typename A2>
  A1 operator () (const A1& a1, const A2& a2) const {
    return a1;
  }
};

class Placeholder2 : public Expression<Placeholder2> {
 public:
  template <typename A1>
  A1 operator () (const A1& a1) const;

  template <typename A1, typename A2>
  A2 operator () (const A1& a1, const A2& a2) const {
    return a2;
  }
};

template <typename T>
class Constant : public Expression<Constant<T> > {
 public:
  Constant(const T& value): value_(value) {
  }

  template <typename A1>
  T operator () (const A1& a1) const {
    return value_;
  }

  template <typename A1, typename A2>
  T operator () (const A1& a1, const A2& a2) const {
    return value_;
  }

 private:
  T value_;
};

template <typename T>
class Reference : public Expression<Reference<T> > {
 public:
  Reference(T& value): value_(value) {
  }

  template <typename A1>
  T& operator () (const A1& a1) const {
    return value_;
  }

  template <typename A1, typename A2>
  T& operator () (const A1& a1, const A2& a2) const {
    return value_;
  }

 private:
  T& value_;
};

#define DECLARE_EXPRESSION(name, op)                                    \
  template <typename E1, typename E2>                                   \
  name<Expression<E1>, Expression<E2> >                                 \
  operator op (const Expression<E1>& e1, const Expression<E2>& e2) {    \
    return name<Expression<E1>, Expression<E2> >(e1, e2);               \
  }                                                                     \
  template <typename E1>                                                \
  name<Expression<E1>, Constant<int> >                                  \
  operator op (const Expression<E1>& e1, int e2) {                      \
    return name<Expression<E1>, Constant<int> >(e1, Constant<int>(e2)); \
  }                                                                     \
  template <typename E2>                                                \
  name<Constant<int>, Expression<E2> >                                  \
  operator op (int e1, const Expression<E2>& e2) {                      \
    return name<Constant<int>, Expression<E2> >(Constant<int>(e1), e2); \
  }

DECLARE_EXPRESSION(PlusExpression, +)
DECLARE_EXPRESSION(MinusExpression, -)
DECLARE_EXPRESSION(LessExpression, <)
DECLARE_EXPRESSION(GreaterExpression, >)
DECLARE_EXPRESSION(OutputExpression, <<)

template <typename E>
OutputExpression<Reference<std::ostream>, Expression<E> >
operator << (std::ostream& os, Expression<E>& e) {
  return OutputExpression<Reference<std::ostream>, Expression<E> >(os, e);
}

Placeholder1 _1;
Placeholder2 _2;

int main() {
  int a[] = { 1, 2, 3, 4, 5 };
  std::for_each(a, a + 5, std::cout << _1);
  std::cout << std::endl;
  std::sort(a, a + 5, _1 > _2);
  std::transform(a, a + 5, std::ostream_iterator<int>(std::cout, " "), _1 + _1);
  std::cout << std::endl;
  return 0;
}
